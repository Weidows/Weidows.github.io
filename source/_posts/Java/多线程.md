---
title: 🌭回顾一下Java多线程.
date: 2021-02-08 18:59:13
categories:
  - Java
tags:
  - Java
  - 多线程
cover: https://i.loli.net/2021/02/08/6UdHDGPQxBN4wV8.png
# top_img:
---

<!--
 * @?: *********************************************************************
 * @Author: Weidows
 * @Date: 2021-02-08 18:59:13
 * @LastEditors: Weidows
 * @LastEditTime: 2021-02-20 14:37:01
 * @FilePath: \Weidowsd:\Game\Github\Blog-private\source\_posts\Java\多线程.md
 * @Description:
 * @!: *********************************************************************
-->

- [参照](#参照)
- [概念](#概念)
- [Maven 自动导入 jar 包](#maven-自动导入-jar-包)
- [多线程并行下载](#多线程并行下载)
  - [实现`Runnable`接口](#实现runnable接口)
  - [实现`Callable`接口](#实现callable接口)
- [静态代理](#静态代理)
- [生命周期](#生命周期)
- [停止线程](#停止线程)
- [线程休眠](#线程休眠)
- [线程让步](#线程让步)

![分割线](https://cdn.jsdelivr.net/gh/Weidows/Images@master/img/divider.png)

# 参照

> [狂神说多线程笔记](https://blog.csdn.net/weixin_41963554/article/details/108808824)

![分割线](https://cdn.jsdelivr.net/gh/Weidows/Images@master/img/divider.png)

# 概念

- main()称为主线程，为系统的入口
- 一个进程中，如果开辟了多个线程，线程的运行由调度器安排，调度器是与操作系统紧密相关的，先后顺序是不能认为干预的(无法预测线程运行顺序)
- 程序运行时,默认会有多个线程,比如 main 和 gc(垃圾回收器)

![分割线](https://cdn.jsdelivr.net/gh/Weidows/Images@master/img/divider.png)

# Maven 自动导入 jar 包

- 比如我们需要导入 Apache 的`commons-io`这个包,去 Maven 仓库搜,可以找到[这个网址](https://mvnrepository.com/artifact/commons-io/commons-io)

- 然后选择一个版本点进去

  <img src="https://i.loli.net/2021/02/11/9o3IUqidJxHOADe.png" alt="20210211010341" />

- 复制框里的内容,找到 Java 项目`pom.xml`文件,粘贴到如下地方

  <img src="https://i.loli.net/2021/02/11/EfbaBX43wZks9mh.png" alt="20210211010614" />

- 然后右键`pom.xml`->Maven->重新加载项目.

  <img src="https://i.loli.net/2021/02/11/ujDCcqliNEh2U58.png" alt="20210211010920" />

- 在 VScode 内的话也有这种操作:

  <img src="https://i.loli.net/2021/02/11/ysPTCunXYpQ5UdV.png" alt="20210211011109" />

- 当然关闭然后重新打开 IDE 也是可以的,Maven 会自动更新,更新后如下,包就导进来了:

  <img src="https://i.loli.net/2021/02/11/lZ4x91mzrn2aIKE.png" alt="20210211011240" />

![分割线](https://cdn.jsdelivr.net/gh/Weidows/Images@master/img/divider.png)

# 多线程并行下载

## 实现`Runnable`接口

```java
package twenty.november.thread.downloader;

import java.io.File;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;

import org.apache.commons.io.FileUtils;

public class Downloader implements Runnable {
  private String url;
  private String fileName;

  public Downloader(String url, String fileName) {
    this.url = url;
    this.fileName = fileName;
  }

  @Override
  public void run() {
    try {
      FileUtils.copyURLToFile(new URL(url), new File(fileName));
      System.out.println("Download finished.");
    } catch (MalformedURLException e) {
      e.printStackTrace();
    } catch (IOException e) {
      e.printStackTrace();
    }
  }

  public static void main(String[] args) {
    new Thread(new Downloader("https://cdn.jsdelivr.net/gh/Weidows/Images@master/img/divider.png",
        "./Java/src/main/java/twenty/november/thread/downloader/1.png")).start();
    new Thread(new Downloader("https://cdn.jsdelivr.net/gh/Weidows/Images@master/img/divider.png",
        "./Java/src/main/java/twenty/november/thread/downloader/2.png")).start();
  }
}
```

---

## 实现`Callable`接口

- Callable 与 Runnable 区别为它可以带有返回值类型,可以抛出异常

```java
package twenty.november.thread.downloader;

import java.io.File;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import org.apache.commons.io.FileUtils;

public class Downloader2 implements Callable<Object> {
  private String url;
  private String fileName;

  @Override
  public Object call() throws MalformedURLException, IOException {
    FileUtils.copyURLToFile(new URL(url), new File(fileName));
    System.out.println(fileName + "下载完成");
    return null;
  }

  public Downloader2(String url, String fileName) {
    this.url = url;
    this.fileName = fileName;
  }

  public static void main(String[] args) {
    // 创建线程池
    ExecutorService ser = Executors.newFixedThreadPool(2);

    // 提交执行
    Future<Object> submit1 = ser
        .submit(new Downloader2("https://cdn.jsdelivr.net/gh/Weidows/Images@master/img/divider.png",
            "./Java/src/main/java/twenty/november/thread/downloader/1.png"));
    Future<Object> submit2 = ser
        .submit(new Downloader2("https://cdn.jsdelivr.net/gh/Weidows/Images@master/img/divider.png",
            "./Java/src/main/java/twenty/november/thread/downloader/2.png"));

    // 获取结果
    try {
      Object result1 = submit1.get();
      Object result2 = submit2.get();
    } catch (InterruptedException | ExecutionException e) {
      e.printStackTrace();
    }

    // 关闭服务
    ser.shutdown();
  }
}
```

![分割线](https://cdn.jsdelivr.net/gh/Weidows/Images@master/img/divider.png)

# 静态代理

```java
package twenty.november.proxy.static_proxy;

public class StaticProxy {
  public static void main(String[] args) {
    MarryProxy proxy = new MarryProxy(new Me("Weidows"));
    proxy.Marry();
  }
}

/**
 * ! 代理和被代理类都实现Marry接口
 */
interface Marry {
  void Marry();
}

/**
 * ! 被代理者
 */
class Me implements Marry {
  public String name;

  @Override
  public void Marry() {
    System.out.println(name + "结婚了");
  }

  public Me(String name) {
    this.name = name;
  }

}

/**
 * ! 代理
 */
class MarryProxy implements Marry {
  private Me target;

  @Override
  public void Marry() {
    before();
    target.Marry();
    after();
  }

  private void after() {
    System.out.println(target.name + "结婚后");
  }

  private void before() {
    System.out.println(target.name + "结婚前");
  }

  public MarryProxy(Me target) {
    this.target = target;
  }

}
```

![分割线](https://cdn.jsdelivr.net/gh/Weidows/Images@master/img/divider.png)

# 生命周期

<img src="https://cdn.jsdelivr.net/gh/Weidows/Images@master/hpp/20210219173514.png" alt="20210219173514" />

---

# 停止线程

1. 建议线程正常停止——>利用次数，不建议死循环
2. 建议使用标志位——>设置一个标志位
3. `不要用` stop 或者 destroy 等过时或者 JDK 不建议使用的方法

```Java
public class TestStop implements Runnable {
  //1.设置一个标志位
  private boolean flag = true;

  @Override
  public void run() {
    int i = 0; // 运行次数
    while (flag) {
      System.out.println("Thread.run()运行次数: " + i++);
    }
  }

  //2.设置一个公开的方法停止线程，转换标志位
  public void stop() {
    this.flag = false;
  }

  public static void main(String[] args) {
    TestStop testStop = new TestStop();
    new Thread(testStop).start();

    for (int i = 0; i < 100; i++) {
      System.out.println("main: " + i);
      if (i == 90) {
        testStop.stop();
        System.out.println("testStop线程停止了,main线程还在运行");
      }
    }
  }
}
```

---

# 线程休眠

```Java
public class TestSleep {
  public static void main(String[] args) {
    try {
      // 十秒倒计时
      tenSecondsDown();

      // 每秒输出系统当前时间
      countTime();
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
  }

  public static void tenSecondsDown() throws InterruptedException {
    int num = 10;
    while (true) {
      Thread.sleep(1000);
      System.out.println(num--);
      if (num == 0)
        break;
    }
  }

  public static void countTime() {
    Date startTime = new Date(System.currentTimeMillis()); //获取系统当前时间
    while (true) {
      try {
        System.out.println(new SimpleDateFormat("HH:mm:ss").format(startTime));
        startTime = new Date(System.currentTimeMillis()); //更新当前时间
        Thread.sleep(1000);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    }
  }
}
```

- 测试数据时可以通过延时来放大线程问题的发生性.

---

# 线程让步

- 令当前线程`暂停但并不阻塞`,有可能让步并不成功.

```Java
public class TestYield {
  public static void main(String[] args) {
    // MyYield myYield = new MyYield();

    // * 匿名内部类的方式
    // Runnable myYield = new Runnable() {
    //   @Override
    //   public void run() {
    //     System.out.println(Thread.currentThread().getName() + "线程开始执行");
    //     Thread.yield(); //礼让
    //     System.out.println(Thread.currentThread().getName() + "线程停止执行");
    //   }
    // };

    // * Lambda表达式方式
    Runnable myYield = () -> {
      System.out.println(Thread.currentThread().getName() + "线程开始执行");
      Thread.yield(); //礼让
      System.out.println(Thread.currentThread().getName() + "线程停止执行");
    };

    new Thread(myYield, "a").start();
    new Thread(myYield, "b").start();
  }
}

// * 新建类的方式实现接口
// class MyYield implements Runnable {
//   @Override
//   public void run() {
//     System.out.println(Thread.currentThread().getName() + "线程开始执行");
//     Thread.yield(); //礼让
//     System.out.println(Thread.currentThread().getName() + "线程停止执行");
//   }
// }
```

- 结果

  - 预期结果,让步成功

  ```
  a线程开始执行
  b线程开始执行
  a线程停止执行
  b线程停止执行
  ```

  - 让步未成功(但也并不能认为是失败,确确实实让了一下)

  ```
  a线程开始执行
  a线程停止执行
  b线程开始执行
  b线程停止执行
  ```
