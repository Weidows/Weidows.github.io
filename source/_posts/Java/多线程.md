---
title: 🌭回顾一下Java多线程.
date: 2021-02-08 18:59:13
categories:
  - Java
tags:
  - Java
  - 多线程
cover: https://i.loli.net/2021/02/08/6UdHDGPQxBN4wV8.png
# top_img:
---

<!--
 * @?: *********************************************************************
 * @Author: Weidows
 * @Date: 2021-02-08 18:59:13
 * @LastEditors: Weidows
 * @LastEditTime: 2021-02-13 17:07:28
 * @FilePath: \Weidowsd:\Game\Github\Blog-private\source\_posts\Java\多线程.md
 * @Description:
 * @!: *********************************************************************
-->

# 参照

> [狂神说多线程笔记](https://blog.csdn.net/weixin_41963554/article/details/108808824)

![分割线](https://cdn.jsdelivr.net/gh/Weidows/Images@master/img/divider.png)

# 概念

- main()称为主线程，为系统的入口
- 一个进程中，如果开辟了多个线程，线程的运行由调度器安排，调度器是与操作系统紧密相关的，先后顺序是不能认为干预的(无法预测线程运行顺序)
- 程序运行时,默认会有多个线程,比如 main 和 gc(垃圾回收器)

![分割线](https://cdn.jsdelivr.net/gh/Weidows/Images@master/img/divider.png)

# Maven 自动导入 jar 包

- 比如我们需要导入 Apache 的`commons-io`这个包,去 Maven 仓库搜,可以找到[这个网址](https://mvnrepository.com/artifact/commons-io/commons-io)

- 然后选择一个版本点进去

  <img src="https://i.loli.net/2021/02/11/9o3IUqidJxHOADe.png" alt="20210211010341" />

- 复制框里的内容,找到 Java 项目`pom.xml`文件,粘贴到如下地方

  <img src="https://i.loli.net/2021/02/11/EfbaBX43wZks9mh.png" alt="20210211010614" />

- 然后右键`pom.xml`->Maven->重新加载项目.

  <img src="https://i.loli.net/2021/02/11/ujDCcqliNEh2U58.png" alt="20210211010920" />

- 在 VScode 内的话也有这种操作:

  <img src="https://i.loli.net/2021/02/11/ysPTCunXYpQ5UdV.png" alt="20210211011109" />

- 当然关闭然后重新打开 IDE 也是可以的,Maven 会自动更新,更新后如下,包就导进来了:

  <img src="https://i.loli.net/2021/02/11/lZ4x91mzrn2aIKE.png" alt="20210211011240" />

![分割线](https://cdn.jsdelivr.net/gh/Weidows/Images@master/img/divider.png)

# 多线程并行下载

## 实现`Runnable`接口

```java
package twenty.november.thread.downloader;

import java.io.File;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;

import org.apache.commons.io.FileUtils;

public class Downloader implements Runnable {
  private String url;
  private String fileName;

  public Downloader(String url, String fileName) {
    this.url = url;
    this.fileName = fileName;
  }

  @Override
  public void run() {
    try {
      FileUtils.copyURLToFile(new URL(url), new File(fileName));
      System.out.println("Download finished.");
    } catch (MalformedURLException e) {
      e.printStackTrace();
    } catch (IOException e) {
      e.printStackTrace();
    }
  }

  public static void main(String[] args) {
    new Thread(new Downloader("https://cdn.jsdelivr.net/gh/Weidows/Images@master/img/divider.png",
        "./Java/src/main/java/twenty/november/thread/downloader/1.png")).start();
    new Thread(new Downloader("https://cdn.jsdelivr.net/gh/Weidows/Images@master/img/divider.png",
        "./Java/src/main/java/twenty/november/thread/downloader/2.png")).start();
  }
}
```

---

## 实现`Callable`接口

- Callable 与 Runnable 区别为它可以带有返回值类型,可以抛出异常

```java
package twenty.november.thread.downloader;

import java.io.File;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import org.apache.commons.io.FileUtils;

public class Downloader2 implements Callable<Object> {
  private String url;
  private String fileName;

  @Override
  public Object call() throws MalformedURLException, IOException {
    FileUtils.copyURLToFile(new URL(url), new File(fileName));
    System.out.println(fileName + "下载完成");
    return null;
  }

  public Downloader2(String url, String fileName) {
    this.url = url;
    this.fileName = fileName;
  }

  public static void main(String[] args) {
    // 创建线程池
    ExecutorService ser = Executors.newFixedThreadPool(2);

    // 提交执行
    Future<Object> submit1 = ser
        .submit(new Downloader2("https://cdn.jsdelivr.net/gh/Weidows/Images@master/img/divider.png",
            "./Java/src/main/java/twenty/november/thread/downloader/1.png"));
    Future<Object> submit2 = ser
        .submit(new Downloader2("https://cdn.jsdelivr.net/gh/Weidows/Images@master/img/divider.png",
            "./Java/src/main/java/twenty/november/thread/downloader/2.png"));

    // 获取结果
    try {
      Object result1 = submit1.get();
      Object result2 = submit2.get();
    } catch (InterruptedException | ExecutionException e) {
      e.printStackTrace();
    }

    // 关闭服务
    ser.shutdown();
  }
}
```

![分割线](https://cdn.jsdelivr.net/gh/Weidows/Images@master/img/divider.png)

# 静态代理

```java
package twenty.november.proxy.static_proxy;

public class StaticProxy {
  public static void main(String[] args) {
    MarryProxy proxy = new MarryProxy(new Me("Weidows"));
    proxy.Marry();
  }
}

/**
 * ! 代理和被代理类都实现Marry接口
 */
interface Marry {
  void Marry();
}

/**
 * ! 被代理者
 */
class Me implements Marry {
  public String name;

  @Override
  public void Marry() {
    System.out.println(name + "结婚了");
  }

  public Me(String name) {
    this.name = name;
  }

}

/**
 * ! 代理
 */
class MarryProxy implements Marry {
  private Me target;

  @Override
  public void Marry() {
    before();
    target.Marry();
    after();
  }

  private void after() {
    System.out.println(target.name + "结婚后");
  }

  private void before() {
    System.out.println(target.name + "结婚前");
  }

  public MarryProxy(Me target) {
    this.target = target;
  }

}
```
