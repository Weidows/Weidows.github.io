---
title: 🌭回顾一下Java多线程~(贰)
date: 2021-02-21 01:06:22
tags:
  - Java
  - 多线程
  - 笔记
cover: https://cdn.jsdelivr.net/gh/Weidows/Images/hpp/6UdHDGPQxBN4wV8.png
top_img:
---

<!--
 * @?: *********************************************************************
 * @Author: Weidows
 * @LastEditors: Weidows
 * @LastEditTime: 2021-02-24 17:17:20
 * @FilePath: \Weidowsd:\Game\Github\Blog-private\source\_posts\Java\多线程\2.md
 * @Description:
 * @!: *********************************************************************
-->

- [线程状态](#线程状态)
- [线程优先级](#线程优先级)
- [守护线程 daemon](#守护线程-daemon)
- [线程同步](#线程同步)
  - [买票](#买票)
  - [银行取款](#银行取款)
    - [试错](#试错)
  - [List](#list)
- [死锁](#死锁)
  - [产生条件](#产生条件)
  - [解决方案](#解决方案)

![分割线](https://cdn.jsdelivr.net/gh/Weidows/Images/img/divider.png)

## 线程状态

<img src="https://cdn.jsdelivr.net/gh/Weidows/Images/hpp/20210221232406.png" alt="20210221232406" />

```java
public class TestState {
  public static void main(String[] args) throws InterruptedException {
    Thread thread = new Thread(() -> {
      for (int i = 0; i < 5; i++) {
        try {
          Thread.sleep(1000);
        } catch (InterruptedException e) {
          e.printStackTrace();
        }
      }
      System.out.println("///");
    });

    //观察状态
    Thread.State state = thread.getState();
    System.out.println(state); //NEW

    //观察后启动
    thread.start(); //启动线程
    state = thread.getState();
    System.out.println(); //Run

    while (state != Thread.State.TERMINATED) { //只要线程不停止，就一直输出状态
      Thread.sleep(100);
      state = thread.getState(); //更新线程状态
      System.out.println(state); //输出状态

      //thread.start();   报错，因为已经死亡的线程不能再启动
    }
  }
}
```

---

## 线程优先级

- 线程的优先级用数字表示，范围从 1~10.

  - Thread.MIN_PRIORITY = 1;
  - Thread.MAX_PRIORITY = 10;
  - Thread.NORM_PRIORITY = 5;

- 使用一下方法改变或获取优先级

  - ​.getPriority()
  - .setPriority(int xxx)

- 不做举例了,跳过.

---

## 守护线程 daemon

- 线程分为`用户线程`和`守护线程`,用户线程必须执行完毕程序才终止,而守护线程不做要求.

```Java
public class TestDaemon {
  public static void main(String[] args) {
    // ! 上帝
    Runnable god = () -> {
      while (true) {
        System.out.println("上帝保佑你");
      }
    };
    // ! 你
    Runnable you = () -> {
      for (int i = 0; i < 100; i++) {
        System.out.println("你一生都开心的活着");
      }
      System.out.println("GoodBye World");
    };

    Thread godThread = new Thread(god);
    godThread.setDaemon(true); //默认false表示是用户线程，正常的线程都是用户线程
    godThread.start();

    new Thread(you).start();
  }
}
```

- 结果: "you"线程终止时程序就结束了.

  ```
  ...
  上帝保佑你
  上帝保佑你
  你一生都开心的活着
  你一生都开心的活着
  你一生都开心的活着
  你一生都开心的活着
  上帝保佑你
  上帝保佑你
  上帝保佑你
  上帝保佑你
  上帝保佑你
  上帝保佑你
  上帝保佑你
  上帝保佑你
  上帝保佑你
  上帝保佑你
  上帝保佑你
  上帝保佑你
  GoodBye World
  上帝保佑你
  上帝保佑你
  ```

![分割线](https://cdn.jsdelivr.net/gh/Weidows/Images/img/divider.png)

## 线程同步

- 多个线程操作同一资源时会有问题出现,用 `synchronized` 同步.

### 买票

```Java
public class Ticket implements Runnable {
  private int ticketNums = 10; //票数
  boolean flag = true; //外部停止方法

  @Override
  public void run() {
    while (flag) {
      buy();
    }
  }

  public synchronized void buy() {
    //判断是否有票
    if (ticketNums <= 0) {
      flag = false;
      return;
    }
    //模拟延时
    try {
      Thread.sleep(200);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
    System.out.println(Thread.currentThread().getName() + "-->得到倒数第" + ticketNums-- + "票");
  }

  public static void main(String[] args) {
    Ticket ticket = new Ticket();

    new Thread(ticket, "小明").start();
    new Thread(ticket, "老师").start();
    new Thread(ticket, "黄牛").start();
  }
}
```

- 结果

  ```
  小明-->得到倒数第10票
  小明-->得到倒数第9票
  小明-->得到倒数第8票
  小明-->得到倒数第7票
  小明-->得到倒数第6票
  小明-->得到倒数第5票
  小明-->得到倒数第4票
  小明-->得到倒数第3票
  小明-->得到倒数第2票
  小明-->得到倒数第1票
  ```

---

### 银行取款

```Java
import java.math.BigDecimal;

public class Bank {
  public static void main(String[] args) {
    Account account = new Account(new BigDecimal(100), "我的账户");

    DrawingChannel a = new DrawingChannel(account, new BigDecimal(50), "A");
    DrawingChannel b = new DrawingChannel(account, new BigDecimal(100), "B");

    a.start();
    b.start();
  }
}

//账户
class Account {
  BigDecimal balance;//余额
  final String name; //卡名

  public Account(BigDecimal balance, String name) {
    this.balance = balance;
    this.name = name;
  }
}

/**
 * 银行：模拟取款
 * * 这里之所以没用实现Runnable接口的方式是为了调用Thread类中一些方法
 */
class DrawingChannel extends Thread {
  final Account account; //账户
  BigDecimal drawingMoney; //取了多少钱
  BigDecimal nowMoney; //现在手里有多少钱

  public DrawingChannel(Account account, BigDecimal drawingMoney, String name) {
    super(name);
    this.account = account;
    this.drawingMoney = drawingMoney;
    this.nowMoney = new BigDecimal(0);
  }

  @Override
  public void run() {
    synchronized (account) {
      //判断有没有钱
      if (account.balance.compareTo(drawingMoney) < 0) {
        System.out.println(account.name + "钱不够" + drawingMoney + "," + this.getName() + "无法取走");
        return;
      }

      // 放大错误
      try {
        sleep(1000);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
      draw();
    }
  }

  private void draw() {
    //卡内余额 = 余额 - 取的钱
    account.balance = account.balance.subtract(drawingMoney);
    System.out.println(this.getName() + "取走" + drawingMoney);

    //手里的钱
    nowMoney = nowMoney.add(drawingMoney);

    System.out.println(account.name + "余额为：" + account.balance);
    System.out.println(this.getName() + "手里的钱：" + nowMoney);
  }
}
```

- 预期结果

  ```
  A取走50
  我的账户余额为：50
  A手里的钱：50
  我的账户钱不够100,B无法取走
  ```

---

#### 试错

- 熟练使用.sleep()试错

  - 试错前

    ```
    我的账户钱不够100,B无法取走
    我的账户余额为：50
    A手里的钱：50
    ```

  ***

  - 试错后

    ```
    B 取走 100
    A 取走 50
    我的账户余额为：50
    我的账户余额为：50
    A 手里的钱：50
    B 手里的钱：100
    ```

---

### List

- 多个线程同时操作 List 对象时可能会存在覆写(线程不安全)

- 非线程同步

  ```Java
  import java.util.ArrayList;
  import java.util.List;

  public class TestList {
    public static void main(String[] args) throws InterruptedException {
      List<String> list = new ArrayList<String>();

      for (int i = 0; i < 10000; i++) {
        new Thread(() -> {
          list.add(Thread.currentThread().getName());
        }).start();
      }
      Thread.sleep(3000); // 延时,为了等上面执行完毕
      System.out.println(list.size());//输出：9992
    }
  }
  ```

  ***

- 线程同步

  ```Java
  import java.util.ArrayList;
  import java.util.List;

  public class TestList {
    public static void main(String[] args) throws InterruptedException {
      List<String> list = new ArrayList<String>();

      for (int i = 0; i < 10000; i++) {
        new Thread(() -> {
          synchronized (list) {
            list.add(Thread.currentThread().getName());
          }
        }).start();
      }
      Thread.sleep(3000); // 延时,为了等上面执行完毕
      System.out.println(list.size());//输出：10000
    }
  }
  ```

  ***

- 线程安全 List

  ```Java
  import java.util.List;
  import java.util.concurrent.CopyOnWriteArrayList;

  public class JUC {
    public static void main(String[] args) {
      List<String> list = new CopyOnWriteArrayList<String>();

      for (int i = 0; i < 10000; i++) {
        new Thread(() -> {
          list.add(Thread.currentThread().getName());
        }).start();
      }

      try {
        Thread.sleep(3000);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }

      System.out.println(list.size());//输出：10000
    }
  }
  ```

![分割线](https://cdn.jsdelivr.net/gh/Weidows/Images/img/divider.png)

## 死锁

- 两线程在各自拥有一个对象的锁时都等待对方线程释放对象的锁

- 也有可能很多线程产生环形死锁或者更复杂的.

- 如下例子就会产生死锁

  ```Java
  //死锁：多个线程互相抱着对方需要的资源
  public class DeadLock {
    public static void main(String[] args) {
      Makeup m1 = new Makeup(0, "小黑");
      Makeup m2 = new Makeup(1, "小白");

      m1.start();
      m2.start();
    }
  }

  //口红
  class Lipstick {
  }

  //镜子
  class Mirror {
  }

  //化妆
  class Makeup extends Thread {
    //需要的资源只有一份，用static来保证只有一份
    static final Lipstick lipstick = new Lipstick();
    static final Mirror mirror = new Mirror();

    int choice; //选择
    String name; //使用化妆品的人

    public Makeup(int choice, String name) {
      this.choice = choice;
      this.name = name;
    }

    @Override
    public void run() {
      //化妆
      try {
        makeup();
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    }

    //化妆，互相持有对方的锁，就是需要拿到对方的资源
    private void makeup() throws InterruptedException {
      if (choice == 0) {
        synchronized (lipstick) { //获得口红的锁
          System.out.println(this.name + "获得口红的锁");
          Thread.sleep(1000);

          synchronized (mirror) { //一秒钟后想获得镜子的锁
            System.out.println(this.name + "获得镜子的锁");
          }
        }
      } else {
        synchronized (mirror) { //获得镜子的锁
          System.out.println(this.name + "获得镜子的锁");
          Thread.sleep(2000);
          synchronized (lipstick) { //两秒钟后想获得口红的锁
            System.out.println(this.name + "获得口红的锁");
          }
        }
      }
    }
  }
  ```

---

### 产生条件

- 四个必要条件:

  1. 互斥条件：一个资源每次只能被一个进程使用。
  2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
  3. 不剥夺条件：进程已获得的资源，在未使用完之前不能强行剥夺。
  4. 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

---

### 解决方案

- 使用完同步对象后立即释放

  - 比如上面的例子中使用完`口红`或者`镜子`后未释放,再去获取另一个对象的锁,就会产生死锁了
  - 修改: 把 makeup 改为如下

  ```Java
  private void makeup() throws InterruptedException {
    if (choice == 0) {
      synchronized (lipstick) { // 获得口红的锁
        System.out.println(this.name + "获得口红的锁");
        Thread.sleep(1000);
      }
      synchronized (mirror) { // 一秒钟后想获得镜子的锁
        System.out.println(this.name + "获得镜子的锁");
      }
    } else {
      synchronized (mirror) { // 获得镜子的锁
        System.out.println(this.name + "获得镜子的锁");
        Thread.sleep(2000);
      }
      synchronized (lipstick) { // 两秒钟后想获得口红的锁
        System.out.println(this.name + "获得口红的锁");
      }
    }
  }
  ```
