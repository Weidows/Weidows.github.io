---
title: 🌭回顾一下Java多线程~(叁)
date: 2021-02-24 17:14:17
categories:
  - Java
  - 多线程
tags:
  - Java
  - 多线程
  - 笔记
cover: https://cdn.jsdelivr.net/gh/Weidows/Images/hpp/6UdHDGPQxBN4wV8.png
top_img:
---

<!--
 * @?: *********************************************************************
 * @Author: Weidows
 * @LastEditors: Weidows
 * @LastEditTime: 2021-03-19 00:14:47
 * @FilePath: \Weidowsd:\Game\Github\Blog-private\source\_posts\Java\多线程\3.md
 * @Description:
 * @!: *********************************************************************
-->

- [可重入锁 ReentrantLock](#可重入锁-reentrantlock)
- [多线程与循环控制](#多线程与循环控制)
- [延迟对多线程的影响](#延迟对多线程的影响)
  - [一](#一)
  - [二](#二)
  - [三](#三)
- [线程通信](#线程通信)
- [线程池](#线程池)
- [Over](#over)

![分割线](https://cdn.jsdelivr.net/gh/Weidows/Images/img/divider.png)

# 可重入锁 ReentrantLock

- ReentrantLock 类实现了 java.util.concurrent.locks.Lock 接口

- 与 synchronized 区别:

  - ReentrantLock 是显式加解锁,它只能锁代码块
  - 性能比 synchronized 好

- 使用优先度

  - Lock >同步代码块(已经进入了方法体，分配了相应资源) >同步方法(在方法体之外)

- 注意点: 加解锁最好要在 try-finally 里

  ```Java
  try {
    lock.lock(); // 加锁
  } finally {
    lock.unlock(); // 解锁
  }
  ```

- 例子

  ```Java
  import java.util.concurrent.locks.ReentrantLock;

  public class TestLock implements Runnable {
    int ticketNums = 10;
    private final ReentrantLock lock = new ReentrantLock(); // 定义Lock锁

    @Override
    public void run() {
      while (true) {
        try {
          lock.lock(); // 加锁
          if (ticketNums > 0) {
            System.out.println(Thread.currentThread().getName() + "-->拿到了第" + ticketNums-- + "票");
          } else {
            break;
          }
        } finally {
          lock.unlock(); // 解锁
          try {
            Thread.sleep(500);
          } catch (InterruptedException e) {
            e.printStackTrace();
          }
        }
      }
    }

    public static void main(String[] args) {
      TestLock testLock = new TestLock();

      new Thread(testLock, "a").start();
      new Thread(testLock, "b").start();
      new Thread(testLock, "c").start();
    }
  }
  ```

- 结果

  ```
  a-->拿到了第10票
  c-->拿到了第9票
  b-->拿到了第8票
  b-->拿到了第7票
  c-->拿到了第6票
  a-->拿到了第5票
  b-->拿到了第4票
  a-->拿到了第3票
  c-->拿到了第2票
  c-->拿到了第1票
  ```

![分割线](https://cdn.jsdelivr.net/gh/Weidows/Images/img/divider.png)

# 多线程与循环控制

```Java
import java.util.concurrent.locks.ReentrantLock;

public class TestLock implements Runnable {
  int ticketNums = 10;
  private final ReentrantLock lock = new ReentrantLock(); // 定义Lock锁

  @Override
  public void run() {
    while (ticketNums > 0) {
      try {
        lock.lock(); // 加锁
        Thread.sleep(500);
        System.out.println(Thread.currentThread().getName() + "-->拿到了第" + ticketNums-- + "票");
      } catch (InterruptedException e) {
        e.printStackTrace();
      } finally {
        lock.unlock(); // 解锁
      }
    }
  }

  public static void main(String[] args) {
    TestLock testLock = new TestLock();

    new Thread(testLock, "a").start();
    new Thread(testLock, "b").start();
    new Thread(testLock, "c").start();
  }
}
```

- 上面代码 while 循环会存在判断失误

  ```
  c-->拿到了第10票
  c-->拿到了第9票
  c-->拿到了第8票
  c-->拿到了第7票
  c-->拿到了第6票
  c-->拿到了第5票
  c-->拿到了第4票
  c-->拿到了第3票
  c-->拿到了第2票
  c-->拿到了第1票
  b-->拿到了第0票
  a-->拿到了第-1票
  ```

- ticketNums 在判断之后被多次修改

  - 上面 10~1 次都是 c 线程执行的,它执行后轮到 b 和 a
  - 但是 b 与 a 线程实际上是在`ticketNums=10`时进入的循环,所以会导致`-1`出现

- 所以建议是:
  - 遇到多线程循环控制时,直接`while(true)`,然后在内部用`if`

---

# 延迟对多线程的影响

> 下面三个例子数据都没错,关键看并发数量和执行时间

## 一

- 瞬间执行完,资源被单一线程全部抢占

  ```Java
  import java.util.concurrent.locks.ReentrantLock;

  public class TestLock implements Runnable {
    int ticketNums = 10;
    private final ReentrantLock lock = new ReentrantLock(); // 定义Lock锁

    @Override
    public void run() {
      while (true) {
        try {
          lock.lock(); // 加锁
          if (ticketNums > 0) {
            System.out.println(Thread.currentThread().getName() + "-->拿到了第" + ticketNums-- + "票");
          } else {
            break;
          }
        } finally {
          lock.unlock(); // 解锁
          // try {
          //   Thread.sleep(500);
          // } catch (InterruptedException e) {
          //   e.printStackTrace();
          // }
        }
      }
    }

    public static void main(String[] args) {
      TestLock testLock = new TestLock();

      new Thread(testLock, "a").start();
      new Thread(testLock, "b").start();
      new Thread(testLock, "c").start();
    }
  }
  ```

  ```
  c-->拿到了第9票
  c-->拿到了第8票
  c-->拿到了第7票
  c-->拿到了第6票
  c-->拿到了第5票
  c-->拿到了第4票
  c-->拿到了第3票
  c-->拿到了第2票
  c-->拿到了第1票
  ```

  ***

## 二

- 给他加个延迟试试:

  - 三线程并发,资源分配合理

  ```Java
    public void run() {
      while (true) {
        try {
          lock.lock(); // 加锁
          if (ticketNums > 0) {
            System.out.println(Thread.currentThread().getName() + "-->拿到了第" + ticketNums-- + "票");
          } else {
            break;
          }
        } finally {
          lock.unlock(); // 解锁
          try {
            Thread.sleep(500);
          } catch (InterruptedException e) {
            e.printStackTrace();
          }
        }
      }
    }
  ```

  ```
  b-->拿到了第10票
  a-->拿到了第9票
  c-->拿到了第8票
  b-->拿到了第7票
  a-->拿到了第6票
  c-->拿到了第5票
  c-->拿到了第4票
  a-->拿到了第3票
  b-->拿到了第2票
  b-->拿到了第1票
  ```

  ***

## 三

- 再试试延迟之后解开同步锁

  - 单线执行,资源分配不平衡

  ```Java
    public void run() {
      while (true) {
        try {
          lock.lock(); // 加锁
          if (ticketNums > 0) {
            System.out.println(Thread.currentThread().getName() + "-->拿到了第" + ticketNums-- + "票");
          } else {
            break;
          }
        } finally {
          try {
            Thread.sleep(500);
          } catch (InterruptedException e) {
            e.printStackTrace();
          }
          lock.unlock(); // 解锁
        }
      }
    }
  ```

  ```
  a-->拿到了第10票
  a-->拿到了第9票
  c-->拿到了第8票
  c-->拿到了第7票
  c-->拿到了第6票
  c-->拿到了第5票
  c-->拿到了第4票
  c-->拿到了第3票
  c-->拿到了第2票
  b-->拿到了第1票
  ```

![分割线](https://cdn.jsdelivr.net/gh/Weidows/Images/img/divider.png)

# 线程通信

> [生产者与消费者模型](https://github.com/Weidows/Weidows/blob/master/Java/src/main/java/twenty/november/thread/producer_and_customer/Test.java)

---

# 线程池

- 线程池的出现是为了方便大量的线程创建,回收和管理

- 需要了解 `ExecutorService` 线程池接口;以及 `Executors` 线程池工具类.

  - corePoolSize: 核心池的大小

  - maximumPoolSize:最大线程数

  - keepAliveTime: 线程没有任务时最多保持多长时间后会终止

  - void execute(Runnable command) :执行任务/命令,没有返回值，一般用来执 Runnable

  - <T> Future<T> submit(Callable<T> task) :执行任务,有返回值，一般用来执行 Callable

- 例子

  ```Java
  import java.util.concurrent.Callable;
  import java.util.concurrent.ExecutionException;
  import java.util.concurrent.ExecutorService;
  import java.util.concurrent.Executors;

  public class TestThreadPool {
    public static void main(String[] args) {
      // 1.创建服务，创建线程池
      ExecutorService service = Executors.newFixedThreadPool(10); // 参数为线程池大小
      Runnable myThread = () -> {
        System.out.println(Thread.currentThread().getName());
      };
      Callable<String> myThread2 = () -> {
        return "Running in " + Thread.currentThread().getName();
      };

      // 执行:前五个是Runnable,后五个是Callable
      service.execute(myThread);
      service.execute(myThread);
      service.execute(myThread);
      service.execute(myThread);
      service.execute(myThread);
      try {
        System.out.println(service.submit(myThread2).get());
        System.out.println(service.submit(myThread2).get());
        System.out.println(service.submit(myThread2).get());
        System.out.println(service.submit(myThread2).get());
        System.out.println(service.submit(myThread2).get());
      } catch (InterruptedException | ExecutionException e) {
        e.printStackTrace();
      }

      // 2.关闭连接
      service.shutdown();
    }
  }

  // class MyThread implements Runnable {
  //   @Override
  //   public void run() {
  //     System.out.println(Thread.currentThread().getName());
  //   }
  // }

  // class MyThread2 implements Callable {
  //   @Override
  //   public Object call() throws Exception {
  //     return "Running in " + Thread.currentThread().getName();
  //   }
  // }
  ```

- 结果

  ```
  pool-1-thread-2
  Running in pool-1-thread-6
  pool-1-thread-4
  pool-1-thread-5
  pool-1-thread-3
  pool-1-thread-1
  Running in pool-1-thread-7
  Running in pool-1-thread-8
  Running in pool-1-thread-9
  Running in pool-1-thread-10
  ```

![分割线](https://cdn.jsdelivr.net/gh/Weidows/Images/img/divider.png)

# Over
