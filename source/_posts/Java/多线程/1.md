---
title: 🌭回顾一下Java多线程~(壹)
date: 2021-02-08 18:59:13
tags:
  - Java
  - 多线程
  - 笔记
cover: https://cdn.jsdelivr.net/gh/Weidows/Images/post/6UdHDGPQxBN4wV8.png
top_img:
---

<!--
 * @?: *********************************************************************
 * @Author: Weidows
 * @Date: 2021-02-08 18:59:13
 * @LastEditors: Weidows
 * @LastEditTime: 2021-05-22 10:45:15
 * @FilePath: \Weidowsd:\Game\Github\Blog-private\source\_posts\Java\多线程\1.md
 * @Description:
 * @!: *********************************************************************
-->

- [参照](#参照)
- [概念](#概念)
- [Maven 自动导入 jar 包](#maven-自动导入-jar-包)
- [多线程并行下载](#多线程并行下载)
  - [实现`Runnable`接口](#实现runnable接口)
  - [实现`Callable`接口](#实现callable接口)
- [静态代理](#静态代理)
- [生命周期](#生命周期)
- [停止线程](#停止线程)
- [线程休眠](#线程休眠)
- [线程让步](#线程让步)
- [线程 Join](#线程-join)

<a>![分割线](https://cdn.jsdelivr.net/gh/Weidows/Images/img/divider.png)</a>

## 参照

> 在此文章记录了: [😍Weidows の成长路线.#多线程](../../../others/LearnWay#多线程)

<a>![分割线](https://cdn.jsdelivr.net/gh/Weidows/Images/img/divider.png)</a>

## 概念

- main()称为主线程，为系统的入口
- 一个进程中，如果开辟了多个线程，线程的运行由调度器安排，调度器是与操作系统紧密相关的，先后顺序是不能认为干预的(无法预测线程运行顺序)
- 程序运行时,默认会有多个线程,比如 main 和 gc(垃圾回收器)

<a>![分割线](https://cdn.jsdelivr.net/gh/Weidows/Images/img/divider.png)</a>

## Maven 自动导入 jar 包

- 比如我们需要导入 Apache 的`commons-io`这个包,去 Maven 仓库搜,可以找到[这个网址](https://mvnrepository.com/artifact/commons-io/commons-io)

- 然后选择一个版本点进去

  <img src="https://cdn.jsdelivr.net/gh/Weidows/Images/post/9o3IUqidJxHOADe.png" alt="20210211010341" />

- 复制框里的内容,找到 Java 项目`pom.xml`文件,粘贴到如下地方

  <img src="https://cdn.jsdelivr.net/gh/Weidows/Images/post/EfbaBX43wZks9mh.png" alt="20210211010614" />

- 然后右键`pom.xml`->Maven->重新加载项目.

  <img src="https://cdn.jsdelivr.net/gh/Weidows/Images/post/ujDCcqliNEh2U58.png" alt="20210211010920" />

- 在 VScode 内的话也有这种操作:

  <img src="https://cdn.jsdelivr.net/gh/Weidows/Images/post/ysPTCunXYpQ5UdV.png" alt="20210211011109" />

- 当然关闭然后重新打开 IDE 也是可以的,Maven 会自动更新,更新后如下,包就导进来了:

  <img src="https://cdn.jsdelivr.net/gh/Weidows/Images/post/lZ4x91mzrn2aIKE.png" alt="20210211011240" />

<a>![分割线](https://cdn.jsdelivr.net/gh/Weidows/Images/img/divider.png)</a>

## 多线程并行下载

### 实现`Runnable`接口

```java
package twenty.november.thread.downloader;

import java.io.File;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;

import org.apache.commons.io.FileUtils;

public class Downloader implements Runnable {
  private String url;
  private String fileName;

  public Downloader(String url, String fileName) {
    this.url = url;
    this.fileName = fileName;
  }

  @Override
  public void run() {
    try {
      FileUtils.copyURLToFile(new URL(url), new File(fileName));
      System.out.println("Download finished.");
    } catch (MalformedURLException e) {
      e.printStackTrace();
    } catch (IOException e) {
      e.printStackTrace();
    }
  }

  public static void main(String[] args) {
    new Thread(new Downloader("https://cdn.jsdelivr.net/gh/Weidows/Images/img/divider.png",
        "./Java/src/main/java/twenty/november/thread/downloader/1.png")).start();
    new Thread(new Downloader("https://cdn.jsdelivr.net/gh/Weidows/Images/img/divider.png",
        "./Java/src/main/java/twenty/november/thread/downloader/2.png")).start();
  }
}
```

---

### 实现`Callable`接口

- Callable 与 Runnable 区别为它可以带有返回值类型,可以抛出异常

```java
package twenty.november.thread.downloader;

import java.io.File;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import org.apache.commons.io.FileUtils;

public class Downloader2 implements Callable<Object> {
  private String url;
  private String fileName;

  @Override
  public Object call() throws MalformedURLException, IOException {
    FileUtils.copyURLToFile(new URL(url), new File(fileName));
    System.out.println(fileName + "下载完成");
    return null;
  }

  public Downloader2(String url, String fileName) {
    this.url = url;
    this.fileName = fileName;
  }

  public static void main(String[] args) {
    // 创建线程池
    ExecutorService ser = Executors.newFixedThreadPool(2);

    // 提交执行
    Future<Object> submit1 = ser
        .submit(new Downloader2("https://cdn.jsdelivr.net/gh/Weidows/Images/img/divider.png",
            "./Java/src/main/java/twenty/november/thread/downloader/1.png"));
    Future<Object> submit2 = ser
        .submit(new Downloader2("https://cdn.jsdelivr.net/gh/Weidows/Images/img/divider.png",
            "./Java/src/main/java/twenty/november/thread/downloader/2.png"));

    // 获取结果
    try {
      Object result1 = submit1.get();
      Object result2 = submit2.get();
    } catch (InterruptedException | ExecutionException e) {
      e.printStackTrace();
    }

    // 关闭服务
    ser.shutdown();
  }
}
```

<a>![分割线](https://cdn.jsdelivr.net/gh/Weidows/Images/img/divider.png)</a>

## 静态代理

```java
package twenty.november.proxy.static_proxy;

public class StaticProxy {
  public static void main(String[] args) {
    MarryProxy proxy = new MarryProxy(new Me("Weidows"));
    proxy.Marry();
  }
}

/**
 * ! 代理和被代理类都实现Marry接口
 */
interface Marry {
  void Marry();
}

/**
 * ! 被代理者
 */
class Me implements Marry {
  public String name;

  @Override
  public void Marry() {
    System.out.println(name + "结婚了");
  }

  public Me(String name) {
    this.name = name;
  }

}

/**
 * ! 代理
 */
class MarryProxy implements Marry {
  private Me target;

  @Override
  public void Marry() {
    before();
    target.Marry();
    after();
  }

  private void after() {
    System.out.println(target.name + "结婚后");
  }

  private void before() {
    System.out.println(target.name + "结婚前");
  }

  public MarryProxy(Me target) {
    this.target = target;
  }

}
```

<a>![分割线](https://cdn.jsdelivr.net/gh/Weidows/Images/img/divider.png)</a>

## 生命周期

<img src="https://cdn.jsdelivr.net/gh/Weidows/Images/post/20210219173514.png" alt="20210219173514" />

---

## 停止线程

1. 建议线程正常停止——>利用次数，不建议死循环
2. 建议使用标志位——>设置一个标志位
3. `不要用` stop 或者 destroy 等过时或者 JDK 不建议使用的方法

```Java
public class TestStop implements Runnable {
  //1.设置一个标志位
  private boolean flag = true;

  @Override
  public void run() {
    int i = 0; // 运行次数
    while (flag) {
      System.out.println("Thread.run()运行次数: " + i++);
    }
  }

  //2.设置一个公开的方法停止线程，转换标志位
  public void stop() {
    this.flag = false;
  }

  public static void main(String[] args) {
    TestStop testStop = new TestStop();
    new Thread(testStop).start();

    for (int i = 0; i < 100; i++) {
      System.out.println("main: " + i);
      if (i == 90) {
        testStop.stop();
        System.out.println("testStop线程停止了,main线程还在运行");
      }
    }
  }
}
```

---

## 线程休眠

```Java
public class TestSleep {
  public static void main(String[] args) {
    try {
      // 十秒倒计时
      tenSecondsDown();

      // 每秒输出系统当前时间
      countTime();
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
  }

  public static void tenSecondsDown() throws InterruptedException {
    int num = 10;
    while (true) {
      Thread.sleep(1000);
      System.out.println(num--);
      if (num == 0)
        break;
    }
  }

  public static void countTime() {
    Date startTime = new Date(System.currentTimeMillis()); //获取系统当前时间
    while (true) {
      try {
        System.out.println(new SimpleDateFormat("HH:mm:ss").format(startTime));
        startTime = new Date(System.currentTimeMillis()); //更新当前时间
        Thread.sleep(1000);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    }
  }
}
```

- 测试数据时可以通过延时来放大线程问题的发生性.

---

## 线程让步

- 令当前线程`暂停但并不阻塞`,有可能让步并不成功.

```Java
public class TestYield {
  public static void main(String[] args) {
    // MyYield myYield = new MyYield();

    // * 匿名内部类的方式
    // Runnable myYield = new Runnable() {
    //   @Override
    //   public void run() {
    //     System.out.println(Thread.currentThread().getName() + "线程开始执行");
    //     Thread.yield(); //礼让
    //     System.out.println(Thread.currentThread().getName() + "线程停止执行");
    //   }
    // };

    // * Lambda表达式方式
    Runnable myYield = () -> {
      System.out.println(Thread.currentThread().getName() + "线程开始执行");
      Thread.yield(); //礼让
      System.out.println(Thread.currentThread().getName() + "线程停止执行");
    };

    new Thread(myYield, "a").start();
    new Thread(myYield, "b").start();
  }
}

// * 新建类的方式实现接口
// class MyYield implements Runnable {
//   @Override
//   public void run() {
//     System.out.println(Thread.currentThread().getName() + "线程开始执行");
//     Thread.yield(); //礼让
//     System.out.println(Thread.currentThread().getName() + "线程停止执行");
//   }
// }
```

- 结果

  - 预期结果,让步成功

  ```
  a线程开始执行
  b线程开始执行
  a线程停止执行
  b线程停止执行
  ```

  - 让步未成功(但也并不能认为是失败,确确实实让了一下)

  ```
  a线程开始执行
  a线程停止执行
  b线程开始执行
  b线程停止执行
  ```

---

## 线程 Join

```java
public class TestJoin {
  public static void main(String[] args) throws InterruptedException {
    Runnable testJoin = () -> {
      for (int i = 0; i < 100; i++) {
        System.out.println("vipThread" + i);
      }
    };
    Thread vipThread = new Thread(testJoin);
    vipThread.start();

    //主线程
    for (int i = 0; i < 100; i++) {
      if (i == 50) {
        vipThread.join(); //插队
      }
      System.out.println("main" + i);
    }
  }
}
```

- 结果
  ```
  main0
  vipThread0
  main1
  vipThread1
  vipThread2
  main2
  main3
  vipThread3
  main4
  vipThread4
  main5
  vipThread5
  main6
  vipThread6
  main7
  vipThread7
  main8
  vipThread8
  main9
  vipThread9
  main10
  vipThread10
  main11
  vipThread11
  main12
  vipThread12
  main13
  vipThread13
  main14
  vipThread14
  main15
  vipThread15
  main16
  vipThread16
  main17
  vipThread17
  main18
  vipThread18
  main19
  main20
  vipThread19
  main21
  vipThread20
  vipThread21
  main22
  vipThread22
  main23
  vipThread23
  main24
  main25
  vipThread24
  main26
  main27
  vipThread25
  vipThread26
  main28
  main29
  vipThread27
  main30
  vipThread28
  main31
  main32
  vipThread29
  vipThread30
  main33
  vipThread31
  vipThread32
  vipThread33
  main34
  vipThread34
  main35
  main36
  vipThread35
  vipThread36
  main37
  vipThread37
  main38
  vipThread38
  main39
  vipThread39
  vipThread40
  main40
  vipThread41
  main41
  vipThread42
  main42
  vipThread43
  main43
  vipThread44
  main44
  vipThread45
  main45
  vipThread46
  main46
  vipThread47
  main47
  vipThread48
  main48
  vipThread49
  main49
  vipThread50
  vipThread51
  vipThread52
  vipThread53
  vipThread54
  vipThread55
  vipThread56
  vipThread57
  vipThread58
  vipThread59
  vipThread60
  vipThread61
  vipThread62
  vipThread63
  vipThread64
  vipThread65
  vipThread66
  vipThread67
  vipThread68
  vipThread69
  vipThread70
  vipThread71
  vipThread72
  vipThread73
  vipThread74
  vipThread75
  vipThread76
  vipThread77
  vipThread78
  vipThread79
  vipThread80
  vipThread81
  vipThread82
  vipThread83
  vipThread84
  vipThread85
  vipThread86
  vipThread87
  vipThread88
  vipThread89
  vipThread90
  vipThread91
  vipThread92
  vipThread93
  vipThread94
  vipThread95
  vipThread96
  vipThread97
  vipThread98
  vipThread99
  main50
  main51
  main52
  main53
  main54
  main55
  main56
  main57
  main58
  main59
  main60
  main61
  main62
  main63
  main64
  main65
  main66
  main67
  main68
  main69
  main70
  main71
  main72
  main73
  main74
  main75
  main76
  main77
  main78
  main79
  main80
  main81
  main82
  main83
  main84
  main85
  main86
  main87
  main88
  main89
  main90
  main91
  main92
  main93
  main94
  main95
  main96
  main97
  main98
  main99
  ```
- 可以见到 main 和 vipThread 两个线程几乎同步执行,到了 main49 时,vipThread 会主动插队,这时 vipThread 之外的线程阻塞.
